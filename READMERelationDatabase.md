# <img height="25" src="./images/AILLogoSmall.png" width="40"/> udf-service suplement

<a href="https://www.legosoft.com.mx"><img height="150px" src="./images/icon.jpeg" alt="AI Legorreta" align="left"/></a>
Supplement in how to use Relational database interface.

The `udf-service` is a simple example in how to use different methods to READ, UPDATE or DELETE
data from a any relational database like Postgres (it can be applied to MySQL, MSSQL Server or other
Relational database manufacture)


note: This supplements presents two stack to be used.

## Imperative stack

This is the most common and mature approach that is 100% JPA approach using `Hibernate` as most common 
implementation. 

Other frameworks like Spring Data and `QueryDSL` also born using this imperative stack, before the reactive stack
`R2DBC`. Some developers think that the `R2DBC` is not ready for production environments.

### Introduction:

- `udf` version 1.x and `udf-service`version 2.x are a examples in how to use imperative stack with simple Spring Data
. See code for  both complete examples.
- More microservice for the AI Legorreta marketplace that have a more complex Data model will use this stack since
the reactive stack `R2DBC` still has some problems for complex Data models.
- It is the oldest a more mature stack in comparison with the reactive stack. That it supports 100% JPA specifications 
like relationship `OneToOne`, `OneToMany`, `ManyToMany`, `LAZY` loading, etc. Its implementation is `Hibernate` is 
one of the most used framework.

### Framework dependencies

The microservice `udf` is shown in `maven` and for `udf-service` are shown in `Koltin` gradle.

*__Dependencies:__*

- Driver dependencies for Spring Data are:

```
    <dependency>
       <groupId>org.springframework.boot</groupId>
       <artifactId>spring-boot-starter-data-jpa</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-validation</artifactId>
    </dependency>
```

And for `Kotlin` gradle:

```
	implementation("org.springframework.boot:spring-boot-starter-data-jpa")
	implementation("org.springframework.boot:spring-boot-starter-validation")
```
- Postgres' dependency (for MySQL, MSSQLServer or other relational database use a different dependency)
```
    <dependency>
       <groupId>org.postgresql</groupId>
       <artifactId>postgresql</artifactId>
       <scope>runtime</scope>
    </dependency>
```
And for `Kotlin` gradle:
```
	runtimeOnly("org.postgresql:postgresql")
```
- Flyway's dependency
```
   <dependency>
      <groupId>org.flywaydb</groupId>
      <artifactId>flyway-core</artifactId>
   </dependency>
```
- It is used Lombok for compile Java entity classes:
```
   <dependency>
      <groupId>org.projectlombok</groupId>
      <artifactId>lombok</artifactId>
      <version>1.18.24</version>
      <scope>provided</scope>
   </dependency>
```
And for `Kotlin` gradle:
```
  implementation("org.projectlombok:lombok")
```

### Imperative Entities

The entities utilize all JPA constraints and the `jakarta.persistence.*` annotations as shown in the two
following entities that have a `OneToMany` and `OneToOne` relationships.

note: In order to use QueryDSL these code must be in Java in order to be generated by QueryDSL `Q` classes. If the
developer wants to use `Kotlin` he(she) must follow the example blow this document

*__Examples:__*
```
import com.lmass.param.gql.types.TemplateInput;
import lombok.*;
import org.hibernate.Hibernate;
import org.hibernate.annotations.*;
import jakarta.persistence.*;
import java.time.LocalDate;
import java.util.*;

@Entity
@Table(name = "templates")
@Getter
@Setter
@ToString
@NoArgsConstructor
@AllArgsConstructor
public class Template {
    @Id
    @GeneratedValue
    private UUID        id;

    @Column(name = "name")
    private String      nombre;

    @Column(name = "file_repo")
    private String      fileRepo;

    @Column(name = "channel")
    private DestinoType  destino;

    @Column(name = "json_code")
    private String  json;

    @Column(name = "blockly_blocks")
    private String blockly;

    @CreatedDate
    @Column(name = "creation_date")
    private LocalDate fechaCreacion;
    @LastUpdatedDate
    @Column(name = "modification_date")
    private LocalDate fechaModificacion;

    @Column(name = "author")
    private String autor;

    @Column(name = "active")
    private Boolean activo;

    @Column(name = "fields")
    @OneToMany(mappedBy = "template", cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.LAZY)
    @ToString.Exclude
    private Collection<TemplateField> campos = new ArrayList();

    ...

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || Hibernate.getClass(this) != Hibernate.getClass(o)) return false;
        Template template = (Template) o;
        return id != null && Objects.equals(id, template.id);
    }

    @Override
    public int hashCode() { return id.hashCode(); }

    @Override
    public String toString() {
        return "Template {" +
                "id=" + id +
                ",nombre=" + nombre +
                ",fileRepo=" + fileRepo +
                ",destino=" + destino +
                ",json=" + json +
                ",blockly=" + blockly +
                ",fechaCreacion=" + fechaCreacion +
                ",fechaModificacion=" + fechaModificacion +
                ",autor=" + autor +
                ",activo=" + activo +
                "}";
    }

    public enum DestinoType {
        Email, Reporte, SMS, Web, Otro, NoDefinido;

        // Avoid null values
        public static DestinoType valueOfNull(String value) {
            if (value != null)
                return DestinoType.valueOf(value);
            return null;
        }
    }
}

```

And for TemplateField entity example, the code is as follows:

```
import com.fasterxml.jackson.annotation.JsonBackReference;
import com.lmass.param.gql.types.TemplateFieldInput;
import lombok.*;
import org.hibernate.Hibernate;

import jakarta.persistence.*;
import java.util.Objects;
import java.util.UUID;

@Entity
@Table(name = "template_fields")
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class TemplateField {

    @Id
    @GeneratedValue
    private UUID id;

    @JsonBackReference
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "id_template", referencedColumnName = "id", insertable = true, updatable = false)
    @ToString.Exclude
    private Template template;

    @Column(name = "name")
    private String nombre;

    @Column(name = "type")
    private FieldType tipo;

    @Column(name = "default_value")
    private String valorDefault;

    ...

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || Hibernate.getClass(this) != Hibernate.getClass(o)) return false;
        TemplateField that = (TemplateField) o;
        return id != null && Objects.equals(id, that.id);
    }

    @Override
    public int hashCode() {
        return id.hashCode();
    }

    @Override
    public String toString() {
        return "TemplateField {" +
                "id=" + id +
                ",nombre=" + nombre +
                ",tipo=" + tipo +
                ",valor default=" + valorDefault +
                "}";
    }

    public enum FieldType {
        Texto, Entero, Real, Fecha, ERROR;

        private String toMxGraph() {
            switch (this) {
                case Texto:
                case ERROR: return "String";
                case Entero: return "Integer";
                case Real: return "Double";
                case Fecha: return "Date";
            }
            return null;
        }
    }
}

```

### Imperative Repositories

The repositories are declared as follows (could be in Java or `Kotlin` no difference is important):

*__Examples:__*
```
import com.lmass.param.model.entity.*
import org.springframework.data.jpa.repository.JpaRepository
import org.springframework.data.querydsl.QuerydslPredicateExecutor
import org.springframework.graphql.data.GraphQlRepository
import java.util.*

@GraphQlRepository
interface TemplateRepository : JpaRepository<Template, UUID>, QuerydslPredicateExecutor<Template> {
    fun findTemplateByNombre(nombre: String): Template?
}

interface TemplateFieldRepository : JpaRepository<TemplateField, UUID>

```

### Imperative Flyway

note: This docker also generated the PostgresDB, udfDB.

Or a better method is to use the docker dashboard to start and stop the application.


### Contact AI Legorreta

Feel free to reach out to AI Legorreta on [web page](https://legosoft.com.mx).


Version: 2.0.0
Â©LegoSoft Soluciones, S.C., 2023
